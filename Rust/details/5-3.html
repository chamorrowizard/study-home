<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Notes: Chapter 5.3 - Method Syntax</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: 20px auto; padding: 0 20px; background-color: #fdfdfd; }
        h1 { border-bottom: 3px solid #ce412b; color: #ce412b; padding-bottom: 10px; }
        h2 { color: #2e6da4; border-bottom: 1px solid #ddd; margin-top: 40px; }
        h3 { color: #444; background: #f0f0f0; padding: 5px 10px; border-radius: 4px; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 0.9em; }
        pre { background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 6px; overflow-x: auto; line-height: 1.4; }
        .cheatsheet { background: #fff9e6; border: 2px solid #f1c40f; padding: 20px; border-radius: 10px; margin: 30px 0; }
        .explanation { background: #eef7ff; padding: 15px; border-left: 5px solid #2e6da4; margin: 15px 0; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; background: white; }
        th, td { text-align: left; padding: 12px; border: 1px solid #ddd; }
        th { background-color: #2e6da4; color: white; }
        .rust-keyword { color: #cc99cd; }
        .rust-func { color: #61afef; }
    </style>
</head>
<body>

    <h1>Chapter 5.3: Method Syntax</h1>

    <p>Methods are similar to functions, but they are defined within the <strong>context</strong> of a struct, enum, or trait object. Their primary differentiator is that their first parameter is always <code>self</code>, representing the instance the method is called on.</p>

    <h2>1. Defining Methods</h2>
    <p>To define a method, you use an <code>impl</code> (implementation) block for the specific type.</p>
    
    <pre>
impl Rectangle {
    <span class="rust-keyword">fn</span> <span class="rust-func">area</span>(&<span class="rust-keyword">self</span>) -> u32 {
        <span class="rust-keyword">self</span>.width * <span class="rust-keyword">self</span>.height
    }
}</pre>

    <div class="explanation">
        <strong>Self vs &self:</strong> 
        <ul>
            <li><code>&self</code> is shorthand for <code>self: &Self</code>.</li>
            <li>In an <code>impl</code> block, <code>Self</code> is an alias for the type the block is for.</li>
            <li>Use <code>&self</code> to read data (immutable borrow), <code>&mut self</code> to change data, and <code>self</code> (rare) to take ownership/transform the instance.</li>
        </ul>
    </div>

    <h2>2. Associated Functions</h2>
    <p>Functions defined inside an <code>impl</code> block that <strong>do not</strong> take <code>self</code> as a parameter are called <em>associated functions</em>. These are often used as constructors, such as <code>String::from</code>.</p>

    <pre>
impl Rectangle {
    <span class="rust-keyword">fn</span> <span class="rust-func">square</span>(size: u32) -> Self {
        Self { width: size, height: size }
    }
}</pre>

    <h2>3. Automatic Referencing and Dereferencing</h2>
    <p>Unlike C or C++, Rust does not use a separate <code>-></code> operator for pointers. When you call <code>object.something()</code>, Rust automatically adds <code>&</code>, <code>&mut</code>, or <code>*</code> to match the method's signature.</p>

    <div class="cheatsheet">
        <h2>ðŸš€ Chapter 5.3 Cheatsheet</h2>
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Syntax Example</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Method Call</strong></td>
                    <td><code>rect.area()</code></td>
                    <td>Calls a function defined on an instance.</td>
                </tr>
                <tr>
                    <td><strong>Impl Block</strong></td>
                    <td><code>impl Type { ... }</code></td>
                    <td>The container for all methods of a type.</td>
                </tr>
                <tr>
                    <td><strong>Associated Func</strong></td>
                    <td><code>Type::func()</code></td>
                    <td>Called on the type itself, not an instance (e.g., constructors).</td>
                </tr>
                <tr>
                    <td><strong>Multi-Params</strong></td>
                    <td><code>fn can_hold(&self, other: &Rect)</code></td>
                    <td>Methods can take additional arguments after <code>self</code>.</td>
                </tr>
                <tr>
                    <td><strong>Multiple Blocks</strong></td>
                    <td><code>impl Rect { ... } impl Rect { ... }</code></td>
                    <td>Valid to have multiple <code>impl</code> blocks for one struct.</td>
                </tr>
                <tr>
                    <td><strong>Getters</strong></td>
                    <td><code>fn width(&self) -> u32</code></td>
                    <td>Methods can share names with fields; <code>()</code> distinguishes them.</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2>4. Method Names vs Field Names</h2>
    <p>Rust allows methods to have the same name as a struct field. This is commonly used to create "getters"â€”methods that simply return the value of a private field to make it read-only for users of your library.</p>

    <div class="explanation">
        <strong>Pro Tip:</strong> In your code, <code>rect.width</code> refers to the <strong>field</strong>, while <code>rect.width()</code> refers to the <strong>method</strong>.
    </div>
    <h2>Practice</h2>
    <p><li>Define a Struct: Create a Circle struct with a radius field (use f64 for decimals).</li></p>  
    <p><li>Implement a Method: Use an impl Circle block to define an area method.</li></p>  
    <p><li>Use Self: Remember that your method must take &self as its first parameter to read the radius.</li></p>
    <p><li>Math Tip: You can use std::f64::consts::PI for the value of $\pi$.</li></p>
    <ol>
        <li>Encapsulation: It keeps the math logic (area) right next to the data (radius), making your code easier to maintain.</li>
        <li>Ergonomics: Using c1.area() is often more intuitive than calling a standalone function like calculate_area(&c1).</li>
        <li>Automatic Borrowing: You don't have to worry about adding & manually when calling the method; Rust handles it for you.</li>
    </ol>
    <pre>
    struct Circle {
    radius: f64,
}

impl Circle {
    // Write your area method here
    // It should return f64
}

fn main() {
    let c1 = Circle { radius: 10.0 };
    // Call your method here using c1.area()
}</pre>
<p>Try to write a method called can_hold within your impl Rectangle block. This method should:</p>
<li>Take &self to access the current rectangle's dimensions.</li>
<li>Take a second parameter, other: &Rectangle, which is a reference to another rectangle.</li>
<li>Return a bool (true if the current rectangle is large enough to contain the other one).</li>
<pre>
    #[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Method 1: Existing area method
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // Method 2: Your task! 
    // Return true if self's width and height are BOTH 
    // greater than other's width and height.
    fn can_hold(&self, other: &Rectangle) -> bool {
        // Write logic here
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    
    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
}
</pre>
<h2>Key Concepts to Remember</h2>
<ul>
    <li>The & Sign: We use &Rectangle for the other parameter so that main keeps ownership of the second rectangle and we can use it again later.</li>
    <li>Automatic Referencing: When you call rect1.can_hold(&rect2), Rust automatically handles the complex pointer work for you.</li>
    <li>Getters: Note how the web page shows you can have a method and a field with the same name, like width(); parentheses tell Rust you want the method, not the data field.</li>
</ul>
<pre>
    #[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // The answer: comparing self to another rectangle
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2)); // Output: true
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3)); // Output: false
}
</pre>
<h2>How it Works</h2>
<ol><h4>The Signature: fn can_hold(&self, other: &Rectangle) -> bool.</h4>
    <li>&self lets us read the dimensions of the first rectangle.</li>
    <li>other: &Rectangle lets us read the dimensions of the second rectangle without taking ownership of it.</li>
</ol>
<h2>Key Concepts from this Section</h2><ol>
<li>Method Syntax: We call the logic using rect1.can_hold(&rect2).</li>
<li>Automatic Borrowing: Rust automatically handles the references so you don't have to use complex pointer symbols like -> found in other languages.</li>
<li>Multiple impl blocks: While we put both methods in one block here, Rust allows you to use multiple impl blocks for the same struct if you want to separate them later.</li>
</ol>
</body>
</html>
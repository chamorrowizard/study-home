
      <!doctype html><html><head>
      <meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
      <title>Rust Book 2 Programming a guessing game.odt</title></head><body><p>The Rust Book 2 </p><p>Programming a guessing game</p><p></p><p>Setting up a new project</p><p>$ cargo new guessing_game </p><p>$ cd guessing_game </p><p>-Now cargo run the src/main.rs</p><p></p><p>Processing a guess </p><p>use std::io; //This is from a library that lets user input become output</p><p>fn main() { </p><p>println!(&quot;Guess the number!&quot;); //Printing a prompt that lets the user guess</p><p>println!(&quot;Please input your guess.&quot;); //Macro that prints a sttring to the screen</p><p></p><p>let mut guess = String::new(); //new is an associated function of the string type</p><p>//mutable variable bound to a new, empty string</p><p>io::stdin() //allows us to handle users input</p><p>.read_line(&amp;mut guess) // reads input and stores it in the variable</p><p>.expect(&quot;Failed to read line&quot;); </p><p>println!(&quot;You guessed: {guess}&quot;); </p><p>} </p><p></p><p>-The obtain the user input and then print the result as an output, we need to bring the io input/output library into scope.</p><ul><li>The io library comes from the standard library, known as std:</li><li>use std::io; </li></ul><p></p><p>-By default Rust has a set of items defined in the standard library that it brings into the scope of every program.</p><ul><li>This set is called the prelude</li><li>If a type isn’t in the prelude, you have to bring that type into scope explicitly with a use statement</li></ul><p></p><p>Receiving User input</p><p>-&amp;mut : the &amp; indicates that this argument is a reference</p><ul><li>gives a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times</li></ul><p></p><p>Handling Potential failure with result</p><p>-The read_line puts whatever the user enters into the string we pass to it. </p><p>-It also returns a results value.</p><ul><li>Result is an enumeration (enum)</li><li>A type that can be in one of multiple possible states. </li><li>We call each possible state a variant.</li><li>Result’s variants are ok and err. Ok indicates the operation was successful and it contains the successfully generated value, the err variant means the operation failed, and it contains information about how or why the operation failed.</li></ul><p></p><p>Printing values with println! Placeholders</p><p>println!(&quot;You guessed: {guess}&quot;); </p><p>-This line prints the string that now contains the user’s input. The {} set of curly brackets is a placeholder.</p><p>-Variable name can go inside {} as well as…</p><ul><li>result of an expression</li></ul><p></p><p>Testing the first part</p><p>- Run it using cargo run</p><p></p><p>Generating a Secret number</p><p>-Generate a number that the user will try to guessing</p><p>-Should be different everytime </p><p>-Random number between 1 and 100</p><p>-Rust does not include a random number functionality in its standard library.</p><p>-Rust team does provide a rand crate with said functionality</p><p></p><p>Using a Crate to get More Functionality</p><p>-A crate is a collection of Rust source code files</p><p>-The project that we’ve been building is a binary crate, which is executable</p><p>-The rand crate is a library crate, which contains code that is intended to be used in other programs and can’t be executed on its own.</p><p>-Before we can write code that uses rand, we need to modify the Cargo.toml file to include the rand crate as a dependency</p><p>[dependencies] </p><p>rand = &quot;0.8.5&quot; </p><p>-Cargo understands Semantic versioning (SemVer), which is a standard for writing version numbers.</p><p>-Cargo considers these versions to have public API’s compatible with version 0.8.5</p><p>-When we include an external dependency, Cargo fetches the latest versions of everything that dependency needs from the registry, which is a copy of data from Crates.io</p><ul><li>Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use</li></ul><p>-After updating the registry, Cargo checks the dependencies section and downloads any crates listed that aren’t already downloaded. In this case, we only listed rand as a dependency, Cargo also grabbed other crates that rand depends on to work.</p><p>-After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</p><p></p><p>Ensuring Reproducible Builds with the Cargo.lock file</p><p>-Cargo has a mechanism that ensures you can rebuild the same artifact every time you or anyone else builds your code</p><p>-When you build your project in the future, Cargo will see that the Cargo.lock file exists and will use the versions specified there rather than doing all the work of figuring out versions again.</p><p>-This lets you have a reproducible build automatically. In other words, your project will remain at 0.8.5 until you explicitly upgrade, thanks to cargo.lock file.</p><p></p><p>Updating a crate to Get a New Version</p><p>-Cargo provides the command update (cargo update), which will ignore the Cargo.lock file and figure out all the latest versions that fit your specifications in Cargo.toml.</p><p>-Cargo will then write those versions to the Cargo.lock file</p><p>-In this case, Cargo will only look for versions greater than 0.8.5 and less than 0.9.0</p><ul><li>If you see that there is a 0.9.0 it will tell you, but you’d have to update the Cargo.toml file with rand = “0.9.0”</li></ul><p>-The next time you run cargo build, Cargo will update the registry of crates available and reevaluate your rand requirements according to the new version you have specified</p><p></p><p>Generating a Random Number</p><p>-Let’s start using rand to generate a number to guess. The next step is to update src/main.rs</p><p>use std::io; </p><p>use rand::Rng; </p><p>fn main() { println!(&quot;Guess the number!&quot;); </p><p>let secret_number = rand::thread_rng().gen_range(1..=100); </p><p></p><p>println!(&quot;The secret number is: {secret_number}&quot;); </p><p>println!(&quot;Please input your guess.&quot;); </p><p></p><p>let mut guess = String::new(); io::stdin() </p><p>.read_line(&amp;mut guess) </p><p>.expect(&quot;Failed to read line&quot;); </p><p>println!(&quot;You guessed: {guess}&quot;); </p><p>} </p><p>-First we add the line use rand::Rng;</p><ul><li>The Rng trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods</li></ul><p>-Next, we’re adding two lines in the middle. In the first line, we call the rand::thread_rng function that gives us the particular random number generator we’re going to use: one that is local to the current thread of execution and is seeded by the operating sytem.</p><p>-Then we call the gen_range method on the random number generator.</p><ul><li>This method is defined by the Rng trait that we brought into scope with the use rand::Rng; statement</li><li>The gen_range method takes a range expression as an argument and generates a random number in the range.</li><li>The kind of range expression we’re using here takes the form start..=end and is inclusive on the lower and upper bounds, so we need to specify 1..=100 to request a number between 1 and 100</li><li>Note* each crate has documentation with instruction for using it</li><li>cargo doc --open </li></ul><p>-The second new line prints the secret number. This is useful while we’re developing the program to be able to test it, but we’ll delete it from the final version</p><p></p><p>Comparing the Guess to the Secret Number</p><p>-Now that we have user input and a random number, we can compare them.</p><p>- First we another use statement, bringing a type called std::cmp::Ordering into scope from the standard library.</p><ul><li>The ordering type is another enum and has the variants Less, Greater, and Equal. </li></ul><p>-Then we add 5 new lines at the bottom that use the Ordering type.</p><ul><li>The cmp method compares two values and can be called on anything that can be compared.</li><li>Here its comparing guess to secret_number </li><li>Then it returns a variant of the ordering enum we brought into scope with the use statement.</li><li>We use a match expression to decide what to do next based on which variant of ordering was returned from the call to cmp with the values in guess and secret_number.</li><li>A match expression is made up of arms. An arm consists of a pattern to match against, and the code that should be run if the value given to match fits the arm’s pattern.</li><li>Rust takes the value given to match and looks through each arm’s pattern in turn.</li><li>Patterns and the match construct are powerful Rust features: they let you express a variety of situations your code might encounter and they make sure you handle them all.</li></ul><p></p><p>-Rust has a strong, static type system. However, it also has a type inference. When we wrote let mut guess = String::new(), Rust was able to infer that guess should be a string and didn’t make us write the type.</p><ul><li>The secret_number on the other hand is a number type. </li><li>A few Rust’s number types can have a value between 1 and 100: i32, a 32 bit number; u32, an unsigned 32 bit number; i64, a 64 bit number; as well as others.</li><li>Unless otherwise specified, Rust defaults to an i32, which is the type of secret_number unless you add type information elsewhere that would cause Rust to infer a different numerical type.</li></ul><p>- The code above will result in error; it compares a string and a number type</p><p></p><p>let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;); </p><p>-We create a variable called guess</p><ul><li>We already have a variable called guess; Rust let’s us shadow the previous value with a new one.</li><li>Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables</li><li>This feature is often used when you want to convert a value from one type to another type.</li></ul><p>-We bind this new variable to the expression guess.trim().parse() </p><ul><li>The guess in the expression refers to the original guess variable that contained the input as a sring</li><li>The trim method on a String instance will eliminate any whitespace at the beginning and end, which we must do before we can convert the string to a u32.</li><li>The user must press enter to satisfy read_line and input their guess, which adds a newline character to the string.</li><li>Example 5 and then enter, guess looks like 5\n; the \n represents “newline”</li><li>The trim method eliminates \n resulting in just 5</li><li>The parse method on strings converts a string to another type.</li><li>We need to tell Rust the exact number type we want by using let guess: u32</li><li>The colon (:) after guess tells Rust we’ll annotate the variable’s type</li><li>The u32 annotation in this example program and the comparison with secret_number means Rust will infer that secret_number should be a u32 as well</li><li>If parse returns an err result variant because it couldn’t create a number from the string, the expect will crash the game and print the message we give it.</li></ul><p></p><p>Allowing multiple guesses with looping</p><p></p><p>-The loop keyword creates an infinite loop; loop{}</p><p>----------------------------------------------------------------------------------------------------------------------------</p><p>println!(&quot;The secret number is: {secret_number}&quot;); </p><p>loop { </p><p>println!(&quot;Please input your guess.&quot;); </p><p>// --snip-- </p><p>match guess.cmp(&amp;secret_number) { </p><p>Ordering::Less =&gt; println!(&quot;Too small!&quot;), </p><p>Ordering::Greater =&gt; println!(&quot;Too big!&quot;), </p><p>Ordering::Equal =&gt; println!(&quot;You win!&quot;), </p><p>} </p><p>} //loop end bracket</p><p>} </p><p>----------------------------------------------------------------------------------------------------------------------------</p><p></p><p>-Exit the loop wit ctrl+c or type a string that throws an error</p><p></p><p>Quitting after a correct guess</p><p>- Let’s program the game to quit when the user wins by adding a break statement</p><p></p><p>Ordering::Equal =&gt; { </p><p>println!(&quot;You win!&quot;); </p><p>break; </p><p>-Adding this break (after “You win!”) will make the program exit the loop</p><p></p><p>Handling Invalid Input</p><p>-To further refine the game’s behavior, rather than crashing the program when the user inputs a non-number. Let’s make the game ignore a non-number so the user can continue guessing.</p><ul><li>We can do this by altering the line where guess is converted from a string to a u32 </li></ul><p>let guess: u32 = match guess.trim().parse() { </p><p>Ok(num) =&gt; num, </p><p>Err(_) =&gt; continue, </p><p>}; </p><p>- We switched from an expect call to a match expression to move from crashing on an error to handling the error.</p><p>-Remember that parse returns a Result type and Result is an enum that has the variants Ok and Err.</p><ul><li>We’re using the match expression here, as we did with the Ordering result of the cmp method.</li></ul><p>-If parse is able to successfully turn the string into a number, it will return an Ok value that contains the resultant number</p><p>-The Err value does not match the Ok(num) pattern in the first match arm, but it does match the Err(_).</p><ul><li>The underscore,_ , is a catc-all value; in this example, we’re saying we want to match all Err values. This allows the program to execute the second arm’s code (continue).</li></ul></body></html>
    